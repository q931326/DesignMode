暂未完成。

设计模式原则：

1.开闭原则：（对扩展开放，对修改关闭）
2.单一职责原则：（一个对象只有一个职责）
3.里氏替换原则：（任何基类可以出现的地方，子类一定可以出现）
4.依赖倒转原则：（实现依赖于抽象，面向接口编程）
5.迪米特法则：（最少知道原则）（一个类对自己依赖的类越少越好）
6.合成复用原则：（尽量使用合成/聚合的方式，而不是使用继承）
7.接口隔离原则：（每个接口中不存在子类用不到却必须实现的功能，如果存在，将接口拆分）

三大模式及其特点：

一.创造型模式（抽象了实例化过程，帮助一个系统独立于创建、组合和表示对象，关注一个对象或类的实例化）

1.解释器模式：
	优点：良好的扩展性，实现难度低
	缺点：执行效率低，类膨胀问题
2.建造者模式：
	将一个复杂对象的构建过程与其表示分离，使得同样的构建过程，可以创建不同的表示。
	优点：封装性好，扩展性好
	缺点：增加了类的数量，内部修改困难（如果产品变化，建造者也要相应变化）
3.简单工厂模式：
	优点：简单直观
	缺点：要增加新对象必须修改工厂方法，没有关闭修改
4.原型模式：
	 原型模式提供了自我复制的功能，新对象的创建可以通过已有对象进行创建。
	优点：1.可以克隆对象 2.可以克隆预生成原型 3.可以更方便地生成复杂对象  4.可以用继承以外的方式来处理复杂对象的不同配置
	缺点：1.需要为每一个类都配置一个clone方法 2.clone方法位于类的内部，当对已有类进行改造时，需要修改代码，违背了开闭原则
	          3.当进行深拷贝的时候，需要编写较为复杂的代码，而且当对象之间存在多重嵌套时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现复杂。
适用场景：

    1.对象之间相同或相似，及只是个别的几个属性不同时
    2.创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多，需要优化资源
    3.创建一个对象需要频繁的数据准备或访问权限等，需要提高性能或者提高安全性
    4.系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值

5.单例模式：
	 一个类只创建一个唯一的对象，即一次创建多次使用
	优点：提供了对唯一实例的受控访问，由于只存在一个对象，可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高对系统的性能。
	缺点：由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。单例类的职责过重，在一定程度上违背了“单一职责原则”。
	
二.结构型模式（涉及到如何组合类和对象以获得更大的结构，为了更灵活的构造对象，关注多个对象或类组合成更复杂的对象）

1.适配器模式：
	让原本不兼容的类或者函数可以协同运作
	优点：    	可以有效地解决接口的兼容性问题
	缺点：	过多地使用适配器，会让系统非常零乱，不易整体进行把握。
2.桥接模式：
	将抽象化与实现化分离，使得二者可以独立地变化。桥接模式是把继承关系转化成了组合关系。实现了抽象与实现分离
	优点：	1.将现实抽离出来，再实现抽象，使得对象的具体实现依赖于抽象，满足了依赖倒转原则
		2.将可以共享的变化部分，抽离出来，减少了代码的重复信息
		3.对象的具体实现可以更加灵活，可以满足多个因素的要求
		4.提高了系统可扩展性，某个维度需要扩展只需要增加实现类接口或者具体实现类，而且不影响另一个维度，符合开闭原则
	缺点：	1.会增加系统的理解与设计难度，因为关联关系建立在抽象层，需要一开始就在抽象层进行设计与编程
		2.要求正确识别出系统中两个或多个独立变化的维度，如何准确识别系统中的两个维度是应用桥接模式的难点
3.装饰器模式：
	 在不改变原类文件或使用继承的前提下，动态的拓展一个对象，进而达到增强或者增加对象的目的
	优点：	1.灵活性好，相比继承，装饰器模式拓展对象功能更加灵活
    		2.扩展性好，不同装饰组合，可以创造出各式各样的对象，且避免了类爆炸
    		3.满足设计模式要求的开闭原则和复用原则
    		4.透明性好，客户端针对抽象操作，对具体实现的内容不可见
	缺点：	复杂度高
4.外观模式：
	优点：	1.简化客户端与子系统之间的交互，使得客户端更容易使用子系统
    		2.可以降低客户端与子系统之间的耦合度，使得客户端不需要直接与子系统交互
    		3.可以在不影响客户端的情况下改变子系统的实现
	缺点：	可能会限制客户端对子系统的访问，因为客户端只能通过外观类来访问子系统
5.享元模式：
	优点：	1.可以减少内存占用，提高程序的性能。它通过共享对象来减少对象的数量，从而减少内存占用
		2.它可以提高程序的执行速度。由于对象减少，程序在运行时需要处理的对象也减少了，因此程序的执行速度会加快
	缺点：	1.享元模式会增加程序的复杂性。您需要将对象的状态分为内部状态和外部状态，并在实现享元对象时考虑如何共享内部状态。
		2.它可能会增加程序的维护成本，由于享元模式将对象的创建和使用分离，需要在客户端代码中管理外部状态，并使用享元模式对象时将外部状态传递给它
6.代理模式：
	优点：	1.指责清晰，真实对象专注于自身业务逻辑，不用考虑其他非本职内容，交给代理完成
		2.高扩展性，真实对象的改变不影响代理
		3.解耦，将客户端与真实对象分离，降低系统耦合度
		4.提高性能，虚拟代理可以减少系统资源的消耗
		5.高安全性和稳定性，代理能更好地控制访问，提高系统安全
	缺点：	1.增加系统复杂度。代理的职责冗杂	  2.请求速度低。客户端与真实对象中加入代理，一定程度上会降低整个系统流程的运行效率

三.行为型模式（涉及到算法和对象间职责的分配）

1.职责链模式：
2.命令模式：
3.解释器模式（同属于创造型模式）
4.迭代器模式：
5.中介者模式：
6.备忘录模式：
7.观察者模式：
8.状态模式：
9.策略模式：
10.模板模式：
11.访问者模式：


遇到的问题：在写工厂模式时，分别写了这两条语句，return make_shared<Banana>();和return shared_ptr<Banana>();
结果第二条语句报错，错误原因为共享指针指向内容为空。
shared_ptr和make_shared的主要区别在于：

shared_ptr是一个智能指针，它可以自动管理对象的生命周期，当没有任何指针指向该对象时，对象会被自动删除。
make_shared是一个辅助函数，用于创建一个shared_ptr实例并分配内存。它比直接使用new操作符创建shared_ptr更加高效，
因为它可以一次性分配内存并构造对象，避免了多次分配和释放内存的开销。
