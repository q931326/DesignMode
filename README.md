设计模式原则：

1.开闭原则：（对扩展开放，对修改关闭）

2.单一职责原则：（一个对象只有一个职责）

3.里氏替换原则：（任何基类可以出现的地方，子类一定可以出现）

4.依赖倒转原则：（实现依赖于抽象，面向接口编程）

5.迪米特法则：（最少知道原则）（一个类对自己依赖的类越少越好）

6.合成复用原则：（尽量使用合成/聚合的方式，而不是使用继承）

7.接口隔离原则：（每个接口中不存在子类用不到却必须实现的功能，如果存在，将接口拆分）

三大模式及其特点：

一.创造型模式（抽象了实例化过程，帮助一个系统独立于创建、组合和表示对象，关注一个对象或类的实例化）

1.解释器模式：
优点：良好的扩展性，实现难度低
缺点：执行效率低，类膨胀问题

2.建造者模式：
将一个复杂对象的构建过程与其表示分离，使得同样的构建过程，可以创建不同的表示。
优点：封装性好，扩展性好
缺点：增加了类的数量，内部修改困难（如果产品变化，建造者也要相应变化）

3.简单工厂模式：
优点：简单直观
缺点：要增加新对象必须修改工厂方法，没有关闭修改

4.原型模式：
 原型模式提供了自我复制的功能，新对象的创建可以通过已有对象进行创建。
优点：1.可以克隆对象 2.可以克隆预生成原型 3.可以更方便地生成复杂对象  4.可以用继承以外的方式来处理复杂对象的不同配置
缺点：1.需要为每一个类都配置一个clone方法 2.clone方法位于类的内部，当对已有类进行改造时，需要修改代码，违背了开闭原则
          3.当进行深拷贝的时候，需要编写较为复杂的代码，而且当对象之间存在多重嵌套时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现复杂。
          
适用场景：
1.对象之间相同或相似，及只是个别的几个属性不同时
2.创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多，需要优化资源
3.创建一个对象需要频繁的数据准备或访问权限等，需要提高性能或者提高安全性
4.系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值

5.单例模式：
 一个类只创建一个唯一的对象，即一次创建多次使用
优点：提供了对唯一实例的受控访问，由于只存在一个对象，可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高对系统的性能。
缺点：由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。单例类的职责过重，在一定程度上违背了“单一职责原则”。

二.结构型模式（涉及到如何组合类和对象以获得更大的结构，为了更灵活的构造对象，关注多个对象或类组合成更复杂的对象）

1.适配器模式：
让原本不兼容的类或者函数可以协同运作
优点：     可以有效地解决接口的兼容性问题
缺点： 过多地使用适配器，会让系统非常零乱，不易整体进行把握。

2.桥接模式：
将抽象化与实现化分离，使得二者可以独立地变化。桥接模式是把继承关系转化成了组合关系。实现了抽象与实现分离
优点： 1.将现实抽离出来，再实现抽象，使得对象的具体实现依赖于抽象，满足了依赖倒转原则
    2.将可以共享的变化部分，抽离出来，减少了代码的重复信息
    3.对象的具体实现可以更加灵活，可以满足多个因素的要求
    4.提高了系统可扩展性，某个维度需要扩展只需要增加实现类接口或者具体实现类，而且不影响另一个维度，符合开闭原则
缺点： 1.会增加系统的理解与设计难度，因为关联关系建立在抽象层，需要一开始就在抽象层进行设计与编程
    2.要求正确识别出系统中两个或多个独立变化的维度，如何准确识别系统中的两个维度是应用桥接模式的难点
    
3.装饰器模式：
 在不改变原类文件或使用继承的前提下，动态的拓展一个对象，进而达到增强或者增加对象的目的
优点： 1.灵活性好，相比继承，装饰器模式拓展对象功能更加灵活
        2.扩展性好，不同装饰组合，可以创造出各式各样的对象，且避免了类爆炸
        3.满足设计模式要求的开闭原则和复用原则
        4.透明性好，客户端针对抽象操作，对具体实现的内容不可见
缺点： 复杂度高

4.外观模式：
优点： 1.简化客户端与子系统之间的交互，使得客户端更容易使用子系统
        2.可以降低客户端与子系统之间的耦合度，使得客户端不需要直接与子系统交互
        3.可以在不影响客户端的情况下改变子系统的实现
缺点： 可能会限制客户端对子系统的访问，因为客户端只能通过外观类来访问子系统

5.享元模式：
优点： 1.可以减少内存占用，提高程序的性能。它通过共享对象来减少对象的数量，从而减少内存占用
    2.它可以提高程序的执行速度。由于对象减少，程序在运行时需要处理的对象也减少了，因此程序的执行速度会加快
缺点： 1.享元模式会增加程序的复杂性。您需要将对象的状态分为内部状态和外部状态，并在实现享元对象时考虑如何共享内部状态。
    2.它可能会增加程序的维护成本，由于享元模式将对象的创建和使用分离，需要在客户端代码中管理外部状态，并使用享元模式对象时将外部状态传递给它
    
6.代理模式：
优点： 1.指责清晰，真实对象专注于自身业务逻辑，不用考虑其他非本职内容，交给代理完成
    2.高扩展性，真实对象的改变不影响代理
    3.解耦，将客户端与真实对象分离，降低系统耦合度
    4.提高性能，虚拟代理可以减少系统资源的消耗
    5.高安全性和稳定性，代理能更好地控制访问，提高系统安全
缺点： 1.增加系统复杂度。代理的职责冗杂     2.请求速度低。客户端与真实对象中加入代理，一定程度上会降低整个系统流程的运行效率

三.行为型模式（涉及到算法和对象间职责的分配）

1.职责链模式：
 为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。
优点：1.降低耦合度  2.增强了给对象指派职责的灵活性    3.增加新的请求处理类很方便
缺点：  1.不能保证请求处理一定被处理，因为请求没有明确的接收者    2.系统性能将受到一定影响，而且在进行代码调试时不太方便；3.可能不容易观察运行时的特征

2.命令模式：
将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
优点：封装性好，每个命令都被封装起来
缺点：可能会导致某些系统有过多的具体命令类。

3.解释器模式（同属于创造型模式）

4.迭代器模式：
提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示
优点：1.它支持以不同的方式遍历一个聚合对象，而无需暴露它的内部表示
     2.迭代器简化了聚合类
     3.在迭代器模式中，由于引入了抽象类，增加新的聚合类和迭代器都很方便，无需修改原有代码
缺点：1.由于多了一个抽象层，会增加系统的复杂性    2.对于简单的遍历（如数组）,使用迭代器方式遍历较为繁琐

5.中介者模式：
优点：1.解耦 2.良好扩展性 3.集中交互
缺点：中介者的职责很重要，并且复杂

6.备忘录模式：
 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先的状态
优点：备份的状态是保存在发起人角色之外的，这样，发起人角色就不需要对各个备份的状态进行管理
    当发起人角色的状态有改变时，有可能是个错误的改变，我们使用备忘录模式就可以把这个错误改变还原。
缺点：如果备份的对象存在大量的信息或者创建、恢复操作非常频繁，则可能造成很大的性能开销

7.观察者模式：
定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
优点：1.松散耦合。2.动态关联  3.抽象解耦
缺点：可能导致意外的更新，如果一个观察者在接收到通知后执行了一些操作，这些操作又导致了主题状态的变化，那么就可能会导致意外的更新
    可能导致性能问题    可能增加复杂性
    
8.状态模式：
优点：1.封装了转换规则2.符合开闭原则 3.通过消除臃肿的状态机条件语句简化上下文代码
缺点：如果状态机只有很少的几个状态，或者很少发生改变，反而会增加系统的复杂度

9.策略模式：
优点：1.提供了对“开闭原则”的完美支持，用户可以在不修改原有代码的基础上选择算法或行为，也可以灵活地增加新的算法或行为
        2.可避免使用多重条件判断，降低程序维护难度  3.可拓展性强
缺点：1.会导致策略类增多（类爆炸），后期维护困难   2.所有策略类都对外暴露，客户端的权限太大，安全性弱

10.模板模式：
优点：1.封装不变部分，扩展可变部分2.提取公共代码，便于维护3.行为由父类控制，子类实现（实现代码复用）
缺点：1.每个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大

11.访问者模式：
封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
优点：1.扩展性良好。2.满足单一职责原则。 3.解耦
缺点：1.不易增加类。2.违背了依赖倒置原则 3.破坏封装。
遇到的问题：在写工厂模式时，分别写了这两条语句，return makeshared();和return sharedptr();
结果第二条语句报错，错误原因为共享指针指向内容为空。

sharedptr和makeshared的主要区别在于：
shared_ptr是一个智能指针，它可以自动管理对象的生命周期，当没有任何指针指向该对象时，对象会被自动删除。
makeshared是一个辅助函数，用于创建一个sharedptr实例并分配内存。它比直接使用new操作符创建shared_ptr更加高效，因为它可以一次性分配内存并构造对象，避免了多次分配和释放内存的开销。
