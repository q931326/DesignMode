设计模式原则：

1.开闭原则：（对扩展开放，对修改关闭）
2.单一职责原则：（一个对象只有一个职责）
3.里氏替换原则：（任何基类可以出现的地方，子类一定可以出现）
4.依赖倒转原则：（实现依赖于抽象，面向接口编程）
5.迪米特法则：（最少知道原则）（一个类对自己依赖的类越少越好）
6.合成复用原则：（尽量使用合成/聚合的方式，而不是使用继承）
7.接口隔离原则：（每个接口中不存在子类用不到却必须实现的功能，如果存在，将接口拆分）

三大模式及其特点：

一.创造型模式（抽象了实例化过程，帮助一个系统独立于创建、组合和表示对象，关注一个对象或类的实例化）

1.解释器模式：
	优点：良好的扩展性，实现难度低
	缺点：执行效率低，类膨胀问题
2.建造者模式：
	将一个复杂对象的构建过程与其表示分离，使得同样的构建过程，可以创建不同的表示。
	优点：封装性好，扩展性好
	缺点：增加了类的数量，内部修改困难（如果产品变化，建造者也要相应变化）
3.简单工厂模式：
	优点：简单直观
	缺点：要增加新对象必须修改工厂方法，没有关闭修改
4.原型模式：
	 原型模式提供了自我复制的功能，新对象的创建可以通过已有对象进行创建。
	优点：1.可以克隆对象 2.可以克隆预生成原型 3.可以更方便地生成复杂对象  4.可以用继承以外的方式来处理复杂对象的不同配置
	缺点：1.需要为每一个类都配置一个clone方法 2.clone方法位于类的内部，当对已有类进行改造时，需要修改代码，违背了开闭原则
	          3.当进行深拷贝的时候，需要编写较为复杂的代码，而且当对象之间存在多重嵌套时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现复杂。
适用场景：

    1.对象之间相同或相似，及只是个别的几个属性不同时
    2.创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多，需要优化资源
    3.创建一个对象需要频繁的数据准备或访问权限等，需要提高性能或者提高安全性
    4.系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值

5.单例模式：
	 一个类只创建一个唯一的对象，即一次创建多次使用
	优点：提供了对唯一实例的受控访问，由于只存在一个对象，可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高对系统的性能。
	缺点：由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。单例类的职责过重，在一定程度上违背了“单一职责原则”。
	
二.结构型模式（涉及到如何组合类和对象以获得更大的结构，为了更灵活的构造对象，关注多个对象或类组合成更复杂的对象）

1.适配器模式：
2.桥接模式：
3.组合实体模式：
4.装饰器模式：
5.外观模式：
6.享元模式：
7.代理模式：

三.行为型模式（涉及到算法和对象间职责的分配）

1.职责链模式：
2.命令模式：
3.解释器模式（同属于创造型模式）
4.迭代器模式：
5.中介者模式：
6.备忘录模式：
7.观察者模式：
8.状态模式：
9.策略模式：
10.模板模式：
11.访问者模式：


遇到的问题：在写工厂模式时，分别写了这两条语句，return make_shared<Banana>();和return shared_ptr<Banana>();
结果第二条语句报错，错误原因为共享指针指向内容为空。
shared_ptr和make_shared的主要区别在于：

shared_ptr是一个智能指针，它可以自动管理对象的生命周期，当没有任何指针指向该对象时，对象会被自动删除。
make_shared是一个辅助函数，用于创建一个shared_ptr实例并分配内存。它比直接使用new操作符创建shared_ptr更加高效，
因为它可以一次性分配内存并构造对象，避免了多次分配和释放内存的开销。
